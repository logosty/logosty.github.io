# 线程
+ 线程状态：new，runnable(running，ready)，timeWaiting，waiting，blocked，Terminated
+ 启动方法：runnable.start(); new Thread(Runnable r);
+ synchronized: 偏向（对象头），轻量（自旋，占cpu），重量（os，等待）
+ synchronized：锁对象，（this，xx.class）

# volatile
+ 保证线程可见性
    + cpu 缓存一致性协议
+ 禁止指令重排序
    + 单例双重检查锁案例
+ 不保证原子性
    + i++    

# 锁优化
+ 锁细化
+ 锁粗化（竞争太频繁）

# cas
+ compare and swap
+ atomic包 unsafe 类
+ cpu 原语
+ aba 问题
    + 时间戳/版本号 AtomicStampedReference 可以用版本号
    
+ LongAdder 分段锁cas
    
# unsafe
+ allocateMemory 直接分配内存
+ compareAndSetXX 

# BIO,NIO
![](https://raw.githubusercontent.com/logosty/picture/master/img/20200805164940.png)
## BIO
![](https://raw.githubusercontent.com/logosty/picture/master/img/20200805170926.png)
+ 阻塞的，效率低下，线程和fd一对一
## NIO 第一版
![](https://raw.githubusercontent.com/logosty/picture/master/img/20200805171002.png)
+ 用户线程不断轮询，线程和fd一对多，但是用户线程需要轮询非常多次，多次调用内核，成本大
## NIO 第二版 select
![](https://raw.githubusercontent.com/logosty/picture/master/img/20200805171033.png)
+ 用户线程调用select，内核做轮询。但是需要传参拷贝fd list
## NIO 第三版 epoll
![](https://raw.githubusercontent.com/logosty/picture/master/img/20200805171033.png)
+ 用户线程和内核共享内存（mmap），解决了传递fd list 的问题
 
# 零拷贝
![](https://raw.githubusercontent.com/logosty/picture/master/img/20200805171351.png)
+ 数据不经过内核态，直接指定 in 和 out （sendfile方法）

# epoll + 零拷贝 = kafka
![](https://raw.githubusercontent.com/logosty/picture/master/img/20200805171606.png)
+ 生产者写入通过mmap将数据从网卡存储到磁盘
+ 消费者通过零拷贝直接将数据从磁盘发送到网卡
