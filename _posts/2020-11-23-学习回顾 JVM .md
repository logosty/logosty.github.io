---
tags: [summary,java,jvm]
title: 知识总结 jvm
key: summary
pageview: true
comment: true
---
# 类加载过程 
> 加载->验证->准备->解析->初始化 

* 加载：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象。
* 验证：文件格式验证，元数据验证，字节码验证，符号引用验证。
* 准备：为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值)，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。
* 解析：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析(这里涉及到字节码变量的引用。
* 初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。
* 使用
* 卸载

# 类加载器
## 启动（Bootstrap）
+ c++ 实现，所以在java代码中get体现为null。负责将 Java_Home/lib下面的类库加载到内存中（比如rt.jar）。 
## 扩展（Extension）
+ 是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。
## 系统（App）
+ 是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统（System）加载器。
## 自定义(Custom)
+ 开发者自己定义
+自定义只需继承ClassLoader类，重写findClass方法。其中可使用defineClass方法将class文件的二进制byte数组转化为class类
+自定义类加载器加载自加密的class，可防止反编译，防止篡改
+ <font color=red>parent是如何指定的，打破双亲委派</font>
   1. 用super(parent)指定
   2. 双亲委派的打破
      1. 如何打破：重写loadClass（）
      2. 何时打破过？
         1. JDK1.2之前，自定义ClassLoader都必须重写loadClass()
         2. ThreadContextClassLoader可以实现基础类调用实现类代码，通过thread.setContextClassLoader指定
         3. 热启动，热部署
            1. osgi tomcat 都有自己的模块指定classloader（可以加载同一类库的不同版本）

## 双亲委派模型
+ 出于安全考虑。首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

## Object o = new Obejct() 的半初始化问题
```
    0 new #2 <java/lang/Object>
    3 dup
    4 invokespecial #1 <java/lang/Object.<init>>
    7 astore_1
    8 return
```
* 发生指令重排序，astore_1 如果在 invokespecial 前执行，就会产生引用到空内存的未初始化对象。

# 内存屏障
## inter x86 架构 cpu 硬件级实现
+ Lfence 前后都是 load 的屏障
+ Sfence 前后都是 save 的屏障
+ Mfence 前后任意 的屏障

## jvm 内存屏障
+ LoadStore 前 load 后 store
+ LoadLoad
+ StoreLoad
+ StoreStore

# volatile 各层次实现
## 字节码层面（class文件）
+ 仅仅增加一行 ACC_VOLATILE 具体实现由jvm决定 

![](https://cdn.jsdelivr.net/gh/logosty/picture/img/1606276293593-1606276293588.png)
## jvm 实现
+ StoreStore | volatile写 | StoreLoad
+ LoadLoad | volatile读 | LoadStore
## 硬件
+ X86 : lock cmpxchg 实现

# 对象
## 对象的创建过程
+ 类的加载：加载，验证，准备，解析，初始化 + 对象创建：分配内存，成员变量赋默认值，调用构造方法<init>（成员变量顺序赋初始值，调用构造方法）
## 对象的内存布局
### 普通对象
1. 对象头 mark word 8字节
2. 对象头 klass pointer指针  -XX:-UseCompressedOops 为4字节，否则为8字节
3. 实例数据 引用类型：-XX:+UseCompressedOops 为4字节 不开启为8字节（Oops Ordinary Object Pointers 普通对象的指针）
4. pending 对齐，8的倍数
### 数组对象
+ 对象头中多了一个 数组长度 4字节

## 对象头的具体
![](https://cdn.jsdelivr.net/gh/logosty/picture/img/1606288463829-1606288463815.png)
+ gc分代最大只能15 因为只有4位

# 使用JavaAgent测试Object的大小

## 观察虚拟机配置

java -XX:+PrintCommandLineFlags -version

## 实验

1. 新建项目ObjectSize （1.8）

2. 创建文件ObjectSizeAgent

   ```java
   package com.mashibing.jvm.agent;
   
   import java.lang.instrument.Instrumentation;
   
   public class ObjectSizeAgent {
       private static Instrumentation inst;
   
       public static void premain(String agentArgs, Instrumentation _inst) {
           inst = _inst;
       }
   
       public static long sizeOf(Object o) {
           return inst.getObjectSize(o);
       }
   }
   ```

3. src目录下创建META-INF/MANIFEST.MF

   ```java
   Manifest-Version: 1.0
   Created-By: mashibing.com
   Premain-Class: com.mashibing.jvm.agent.ObjectSizeAgent
   ```

   注意Premain-Class这行必须是新的一行（回车 + 换行），确认idea不能有任何错误提示

4. 打包jar文件

5. 在需要使用该Agent Jar的项目中引入该Jar包

6. 运行时需要该Agent Jar的类，加入参数：
   ```
   -javaagent:C:\work\ijprojects\ObjectSize\out\artifacts\ObjectSize_jar\ObjectSize.jar
   ```

7. 如何使用该类：

   ```java
      import com.jvm.agent.ObjectSizeAgent;
      
      public class T03_SizeOfAnObject {
          public static void main(String[] args) {
              System.out.println(ObjectSizeAgent.sizeOf(new Object()));
              System.out.println(ObjectSizeAgent.sizeOf(new int[] {}));
              System.out.println(ObjectSizeAgent.sizeOf(new P()));
          }
      
          private static class P {
                              //8 _markword
                              //4 _oop指针
              int id;         //4
              String name;    //4
              int age;        //4
       
              byte b1;        //1
              byte b2;        //1
      
              Object o;       //4
              byte b3;        //1
      
          }
      }
   ```
   
   
# 5: 运行时数据区Runtime Data Area

![](https://cdn.jsdelivr.net/gh/logosty/picture/img/1606373392590-1606373392577.png)

## PC 程序计数器
+ PC 寄存器，也叫程序计数器。JVM支持多个线程同时运行，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native 方法，则PC寄存器中为空。
## native method stacks
+  java调用的JNI，c和c++写的 这部分主要与虚拟机用到的 Native 方法相关
## jvm stacks
+ 每个线程对应一个栈，每个方法对应一个栈帧
+ 栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误，
## 栈帧 Frame
1. Local variable Table 局部变量表
2. Operand Stack  操作数栈
   对于long的处理（store and load），多数虚拟机的实现都是原子的
   jls 17.7，没必要加volatile
3. Dynamic Linking 指向常量池
4. return address  存放返回值
   a() -> b()，方法a调用了方法b, b方法的返回值放在什么地方

# 7：常用指令
+ store
+ load
+ pop
+ mul
+ sub
+ invoke
    + InvokeStatic
    + InvokeVirtual
    + InvokeInterface
    + InovkeSpecial, 可以直接定位,不需要多态的方法: private 方法,构造方法
    + InvokeDynamic,JVM最难的指令,lambda表达式或者反射或者其他动态语言scala kotlin，或者CGLib ASM，动态产生的class，会用到的指令